<?xml version="1.0" encoding="UTF-8"?>
<!--
UC Berkeley CS186 Database course
Assignment 4

Put your answers in blocks wrapped by "<![CDATA[" and "]]>". Each block is
marked with TODO. Remove the TODO after putting your answer in.

If the "autograde" attribute is "yes" for a question, the question will be
marked using a grading script. Make sure you follow the instructions on the
format for the answers.
-->
<assignment>

<!--
Question 1 SOME EASY STUFF

Connect to the database.  Type "\d" to see the list of relations in the
database.  Use SQL queries to examine these relations. In particular examine
the relation Rankings. Answer the following questions:
-->
<question id="1a" autograde="yes"
  text="What are the attributes of the Students relation?">
<![CDATA[
id, name, school
]]></question>

<question id="1b1" autograde="yes"
  text="How many indexes are built on the Rankings relation?">
<![CDATA[
2
]]></question>

<question id="1b2" autograde="yes"
  text="Name the indexes and write down their type?">
<![CDATA[
rankings_pkey, primary index
gradrate_idx, B+ tree index
]]></question>

<question id="1c" autograde="yes"
  text="How many tuples are there in the Rankings relation?">
<![CDATA[
1302
]]></question>

<question id="1d" autograde="yes"
  text="How many distinct values of state does the query planner estimate there
       are for the Rankings relation?
       (hint: Query pg_stats to find out)">
<![CDATA[
51
]]></question>

<question id="1e" autograde="yes"
  text="How many distinct values of state are there actually in the rankings
        table? (hint: it's probably easiest to run a query to compute
        this!)">
<![CDATA[
51
]]></question>

<question id="1f"
  text="What query did you use to find the answer to E?">
<![CDATA[
select n_distinct from pg_stats WHERE tablename = 'rankings' AND attname = 'state';
]]></question>
	
<!--
Question 2 USING THE QUERY PLAN VIEWER

This question requires you to use the PostgreSQL query plan visualization
command EXPLAIN. Read the documentation for EXPLAIN at the link given above.
Note that (like System R) EXPLAIN estimates query costs in units of disk I/Os
(CPU instructions are added in by multiplying times a conversion factor).
Consider the following query:

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the query plan generated by the
EXPLAIN command:
-->
<question id="2a"
  text="Briefly describe the plan chosen.">
<![CDATA[
Sequential Scan on rankings with filter on state.
]]></question>

<question id="2b"
  text="In what order would the tuples be returned by this plan? Why?">
<![CDATA[
Sequential order since the orginal order is preserved.
]]></question>

<question id="2c" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
48.27
]]></question>

<question id="2d"
  text="What is the estimated result cardinality for this plan? Looking at the
        statistics, why does the optimizer come up with this estimate?">
<![CDATA[
70. The reason is because we have to go through each row since we are doing a sequential scan.
]]></question>

<question id="2e" autograde="yes"
  text="How many colleges actually do have state = 'CA'?">
<![CDATA[
70
]]></question>

<question id="2f"
  text="Looking at the statistics, what are the top 5 states with the most
        colleges and the percentage of colleges in each of those state?">
<![CDATA[
NY, 7.7573%
PA, 6.37481%
CA, 5.37634%
TX, 4.6083%
MA, 4.30108%
]]></question>

<question id="2g"
  text="Which value of state is actually the most popular, and how many tuples
        have that state? How did you figure this out (what query did you use)?">
<![CDATA[
I used this query:
select most_common_vals, most_common_freqs from pg_stats WHERE 
tablename = 'rankings' AND attname = 'state' LIMIT 1;
Looking at the hash you can see that gave NY is the most popular state.
If you multiply by the total number of rows you get 101 rows.
]]></question>

<!--
Question 3 SELECTS WITH INDEXES

Consider the same query from previous question: 

SELECT * FROM rankings WHERE state = 'CA'; 

Answer the following questions looking at the plans and the access methods:
-->
<question id="3a"
  text="Create a btree index on the attribute state of the relation Rankings.
        What is the plan chosen for the query now?">
<![CDATA[
Index scan using state index on rankings.
]]></question>

<question id="3b" autograde="yes"
  text="What is the estimated total cost of running the plan?">
<![CDATA[
15.15
]]></question>

<question id="3c"
  text="Compare this plan with the plan obtained in question 2.A above.
        Which is cheaper and why?">
<![CDATA[
This is cheaper since we need only look at the states that have 'CA' in them.
]]></question>

<!--
Question 4 RANGE SELECTS

DROP the index that you created for Question 3. Don't forget to VACUUM ANALYZE
Now analyze the query plan that PostgreSQL comes up for the following query: 

SELECT * FROM rankings WHERE gradrate < 10;

Answer the following questions:
-->
<question id="4a" autograde="yes"
  text="How many ranking tuples that have gradrate &lt; 10 does the
        optimizer think there are?">
<![CDATA[
2  
]]></question>

<question id="4b"
  text="In what order will the tuples be returned by this plan?">
<![CDATA[
 Ordered by gradrate.
]]></question>

<question id="4c"
  text="What is a value of the constant (i.e. '10' in the above query) such
        that the optimizer chooses a different plan? What is that plan and why
        does the optimizer think it will be cheaper than the previous plan when
        used with this new constant?">
<![CDATA[
19. Sequential scan. No, the query thinks it will not be cheaper.
]]></question>

<!--
Question 5 SIMPLE JOIN

Create a B-tree index on 'studentfacultyratio' of the rankings table.
Analyze the query plan for the following query that finds the average salary at
schools who have a student to faculty ratio < 5.

SELECT R.name, F.avesalary 
FROM rankings R, financials F
WHERE R.id = F.id AND R.studentfacultyratio < 5; 

Answer the following questions:
-->
<question id="5a"
  text="What is the estimated cost of this plan?">
<![CDATA[
85.43
]]></question>

<question id="5b" autograde="yes"
  text="What kind of join is used by the plan?">
<![CDATA[
Hash Join
]]></question>

<question id="5c1" autograde="yes"
  text="Disable the join type used in the above plan and re-optimize the query.
        What type of join is used now?">
<![CDATA[
Nested Loop Join
]]></question>

<question id="5c2" autograde="yes"
  text="And what is the total estimated cost of the query?">
<![CDATA[
102.80
]]></question>

<question id="5d"
  text="What relations are sorted in this plan, and why?">
<![CDATA[
None, since neither name or avesalary are in the index.
]]></question>

<!--
Question 6 THREE-WAY JOIN

DROP the index that you created for Question 5, RE-ENABLE (using "SET") the join method you turned off above, Don't forget to VACUUM ANALYZE
Answer the following questions referring to the query below: 

SELECT S.name, R.name, F.avesalary
FROM students S, rankings R, financials F
WHERE S.school = R.id and R.id = F.id;
-->
<question id="6a"
  text="Describe the best plan estimated by the optimizer. List the joins and
        access methods it uses, and the order in which the relations are
        joined.">
<![CDATA[
The optimal result returned by the query is a hash join. First Join students
with financials(outer). For each tuple in rankings run a sequential scan, 
joining with the result above.
]]></question>

<question id="6b"
  text="Modify the query by adding a condition R.studentfacultyratio &lt; 8.
        What is the relational algebra expression for the new join order?
        Why is this new join ordering better for the extended query than the
        ordering obtained in part A?">
<![CDATA[
Hash join is still the best plan but the order of joins is different.
Since we have a filter in studentfaculty ratio we first join rankings with financials,
financials being the outer relation and apply the predicate on rankings. 
Then we can join the result above with students as the oter relation.

]]></question>

<!--
Question 7 SQL

Answer the following questions about the database (by writing queries!):
-->
<question id="7a" autograde="yes"
  text="What is the name of the public school (public = 1) with the highest
        average salary?">
<![CDATA[
SELECT R.name from rankings R, financials F where R.id = F.id and
F.avesalary in (select MAX(F.avesalary) from financials F);
]]></question>

<question id="7b" autograde="yes"
  text="Find the public school (public = 1) with the largest difference
        between instate tuition and out of state tuition that has at least
        one student attending.">
<![CDATA[
SELECT R.name from rankings R where R.outofstatetuition - R.instatetuition
in (select MAX(R.outofstatetuition - R.instatetuition) from rankings R) 
and R.enrolled > 1; 
]]></question>

<question id="7c"
  text="Show a query to find out some other interesting fact in the database
        and tell us what the answer is (or at least summarize it).">
<![CDATA[
Find the schools with a graduation rate of over 90% and yet a  
personal spending of less then 500.
SELECT name, gradrate from rankings where personalspending < 500 
GROUP BY gradrate, name HAVING gradrate > 90;
]]></question>

</assignment>
